{"name":"Slugalicious","body":"Slugalicious\r\n============\r\n\r\n**Easy and powerful URL slugging for Rails 3**\r\n\r\n_*(no monkey-patching required)*_\r\n\r\n|\t\t\t  |\t\t\t\t\t\t\t\t\t|\r\n|:------------|:--------------------------------|\r\n| **Author**  | Tim Morgan \t\t\t\t\t    |\r\n| **Version** | 1.2.1 (Mar 2, 2012) \t\t\t|\r\n| **License** | Released under the MIT license. |\r\n\r\nAbout\r\n-----\r\n\r\nSlugalicious is an easy-to-use slugging library that helps you generate pretty\r\nURLs for your ActiveRecord objects. It's built for Rails 3 and is cordoned off\r\nin a monkey patching-free zone.\r\n\r\nSlugalicious is easy to use and powerful enough to cover all of the most common\r\nuse-cases for slugging. Slugs are stored in a separate table, meaning you don't\r\nhave to make schema changes to your models, and you can change slugs while still\r\nkeeping the old URLs around for redirecting purposes.\r\n\r\nSlugalicious is an intelligent slug generator: You can specify multiple ways to\r\ngenerate slugs, and Slugalicious will try them all until it finds one that\r\ngenerates a unique slug. If all else fails, Slugalicious will fall back on a\r\nless pretty but guaranteed-unique backup slug generation strategy.\r\n\r\nSlugalicious works with the Stringex Ruby library, meaning you get meaningful\r\nslugs via the `String#to_url` method. Below are two examples of how powerful\r\nStringex is:\r\n\r\n```` ruby\r\n\"$6 Dollar Burger\".to_url #=> \"six-dollar-burger\"\r\n\"新年好\".to_url #=> \"xin-nian-hao\"\r\n````\r\n\r\nInstallation\r\n------------\r\n\r\n**Important Note:** Slugalicious is written for Rails 3.0 and Ruby 1.9 only.\r\n\r\nFirstly, add the gem to your Rails project's `Gemfile`:\r\n\r\n```` ruby\r\ngem 'slugalicious'\r\n````\r\n\r\nNext, use the generator to add the `Slug` model and its migration to your\r\nproject:\r\n\r\n```` ruby\r\nrails generate slugalicious\r\n````\r\n\r\nThen run the migration to set up your database.\r\n\r\nUsage\r\n-----\r\n\r\nFor any model you want to slug, include the `Slugalicious` module and call\r\n`slugged`:\r\n\r\n```` ruby\r\nclass User < ActiveRecord::Base\r\n  include Slugalicious\r\n  slugged ->(user) { \"#{user.first_name} #{user.last_name}\" }\r\nend\r\n````\r\n\r\nDoing this sets the `to_param` method, so you can go ahead and start generating\r\nURLs using your models. You can use the `find_from_slug` method to load a record\r\nfrom a slug:\r\n\r\n```` ruby\r\nuser = User.find_from_slug(params[:id])\r\n````\r\n\r\nh3. Multiple slug generators\r\n\r\nThe `slugged` method takes a list of method names (as symbols) or `Procs` that\r\neach attempt to generate a slug. Each of these generators is tried in order\r\nuntil a unique slug is generated. (The output of each of these generators is run\r\nthrough the slugifier to convert it to a URL-safe string. The slugifier is by\r\ndefault `String#to_url`, provided by the Stringex gem.)\r\n\r\nSo, if we had our `User` class, and we first wanted to slug by last name only,\r\nbut then add in the first name if two people share a last name, we'd call\r\n`slugged` like so:\r\n\r\n```` ruby\r\nslugged :last_name, ->(user) { \"#{user.first_name} #{user.last_name}\" }\r\n````\r\n\r\nIn the event that none of these generators manages to make a unique slug, a\r\nfallback generator is used. This generator prepends the ID of the record, making\r\nit guaranteed unique. Let's use the example generators shown above. If we create\r\na user with the name \"Sancho Sample\", he will get the slug \"sample\". Create\r\nanother user with the same name, and that user will get the slug\r\n\"sancho-sample;2\". The semicolon is the default ID separator (and it can be\r\noverridden).\r\n\r\nh3. Scoped slugs\r\n\r\nSlugs must normally be unique for a single model type. Thus, if you have a\r\n`User` named Hammer and a `Product` named hammer, they can both share the\r\n\"hammer\" slug.\r\n\r\nIf you want to decrease the uniqueness scope of a slug, you can do so with the\r\n`:scope` option on the `slugged` method. Let's say you wanted to limit the scope\r\nof a `Product`'s slug to its associated `Department`; that way you could have a\r\nproduct named \"keyboard\" in both the Computer Supplies and the Music Supplies\r\ndepartments. To do so, override the `:scope` option with a method name (as\r\nsymbol) or a `Proc` that limits the scope of the uniqueness requirement:\r\n\r\n```` ruby\r\nclass Product < ActiveRecord::Base\r\n  include Slugalicious\r\n  belongs_to :department\r\n  slugged :name, scope: :department_url_component\r\n\r\n  private\r\n\r\n  def department_url_component\r\n    department.name.to_url + \"/\"\r\n  end\r\nend\r\n````\r\n\r\nNow, your computer keyboard's slug will be \"computer-supplies/keyboard\" and your\r\npiano keyboard's slug will be \"music-supplies/keyboard\". There's an important\r\nthing to notice here: The method or proc you use to scope the slug must return a\r\nproper URL substring. That typically means you need to URL-escape it and add a\r\nslash at the end, as shown in the example above.\r\n\r\nWhen you call `to_param` on your piano keyboard, instead of just \"keyboard\", you\r\nwill get \"music-supplies/keyboard\". Likewise, you can use the\r\n`find_from_slug_path` method to find a record from its full path, slug and scope\r\nincluded. You would usually use this method in conjunction with route globbing.\r\nFor example, we could set up our `routes.rb` file like so:\r\n\r\n```` ruby\r\nget '/products/*path', 'products#show', as: :products\r\n````\r\n\r\nThen, in our `ProductsController`, we load the product from the path slug like\r\nso:\r\n\r\n```` ruby\r\ndef find_product\r\n  @product = Product.find_from_slug_path(params[:path])\r\nend\r\n````\r\n\r\nThis is why it's very convenient to have your `:scope` method/proc not only\r\nreturn the uniqueness constraint, but also the scoped portion of the URL\r\npreceding the slug.\r\n\r\n### Altering and expiring slugs\r\n\r\nWhen a model is created, it gets one slug, marked as the active slug (by\r\ndefault). This slug is the first generator that produces a unique slug string.\r\n\r\nIf a model is updated, its slug is regenerated. Each of the slug generators is\r\ninvoked, and if any of them produces an existing slug assigned to the object,\r\nthat slug is made the active slug. (Priority goes to the first slug generator\r\nthat produces an existing slug [active or inactive]).\r\n\r\nIf none of the slug generators generates a known, existing slug belonging to the\r\nobject, then the first unique slug is used. A new `Slug` instance is created and\r\nmarked as active, and any other slugs belonging to the object are marked as\r\ninactive.\r\n\r\nInactive slugs do not act any differently from active slugs. An object can be\r\nfound by its inactive slug just as well as its active slug. The flag is there so\r\nyou can alter the behavior of your application depending on whether the slug is\r\ncurrent.\r\n\r\nA common application of this is to have inactive slugs 301-redirect to the\r\nactive slug, as a way of both updating search engines' indexes and ensuring that\r\npeople know the URL has changed. As an example of how do this, we alter the\r\n`find_product` method shown above to be like so:\r\n\r\n```` ruby\r\ndef find_product\r\n  @product = Product.find_from_slug_path(params[:path])\r\n  unless @product.active_slug?(params[:path].split('/').last)\r\n    redirect_to product_url(@product), status: :moved_permanently\r\n    return false\r\n  end\r\n  return true\r\nend\r\n````\r\n\r\nThe old URL will remain indefinitely, but users who hit it will be redirected to\r\nthe new URL. Ideally, links to the old URL will be replaced over time with links\r\nto the new URL.\r\n\r\nThe problem is that even though the old slug is inactive, it's still \"taken.\" If\r\nyou create a product called \"Keyboard\", but then rename it to \"Piano\", the\r\nproduct will claim both the \"keyboard\" and \"piano\" slugs. If you had renamed it\r\nto make room for a different product called \"Keyboard\" (like a computer\r\nkeyboard), you'd find its slug is \"keyboard;2\" or similar.\r\n\r\nTo prevent the slug namespace from becoming more and more polluted over time,\r\nwebsites generally expire inactive slugs after a period of time. To do this in\r\nSlugalicious, write a task that periodically checks for and deletes old,\r\ninactive `Slug` records. Such a task could be invoked through a cron job, for\r\ninstance. An example:\r\n\r\n```` ruby\r\nSlug.inactive.where([ \"created_at < ?\", 30.days.ago ]).delete_all\r\n````","tagline":"Easy-to-use and powerful slugging for Rails 3","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}